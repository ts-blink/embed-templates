(function (global, factory) {
  typeof exports === "object" && typeof module !== "undefined"
    ? factory(exports)
    : typeof define === "function" && define.amd
    ? define(["exports"], factory)
    : ((global =
        typeof globalThis !== "undefined" ? globalThis : global || self),
      factory((global.tsembed = {})));
})(this, function (exports) {
  "use strict";

  // eslint-disable-next-line no-shadow
  (function (AuthType) {
    AuthType["SSO"] = "SSO";
    AuthType["AuthServer"] = "AuthServer";
  })(exports.AuthType || (exports.AuthType = {}));
  (function (EventType) {
    EventType["Init"] = "init";
    EventType["Load"] = "load";
  })(exports.EventType || (exports.EventType = {}));
  const DEFAULT_EMBED_WIDTH = 500;
  const DEFAULT_EMBED_HEIGHT = 500;
  /**
   * A simple ID generator that meets the following goals:
   * 1. Provide a way to generate a string guaranteed to be unique when compared
   *    to other strings generated by this function.
   * 2. Make the string complex enough that it is highly unlikely to be
   *    accidentally duplicated by hand (this is key if you're using `ID`
   *    as a private/protected name on an object).
   * Hat-tip: https://gist.github.com/gordonbrander/2230317
   */
  const id = () => Math.random().toString(36).substr(2, 9);
  let config = {};
  const init = (embedConfig) => {
    config = embedConfig;
  };
  const getThoughtSpotHost = () => {
    return config.thoughtSpotHost;
  };
  class TsEmbed {
    constructor(domSelector) {
      this.el = document.querySelector(domSelector);
      this.id = id();
      this.thoughtSpotHost = getThoughtSpotHost();
      this.eventHandlerMap = new Map();
    }
    executeCallbacks(eventType, data) {
      const callbacks = this.eventHandlerMap.get(eventType) || [];
      callbacks.forEach((callback) => {
        setTimeout(() => callback(data));
      });
    }
    throwInitError() {
      throw new Error("You need to init the ThoughtSpot SDK module first");
    }
    subscribeToEvents() {
      window.addEventListener("message", (event) => {
        var _a, _b;
        const eventType =
          (_a = event.data) === null || _a === void 0 ? void 0 : _a.type;
        const embedId =
          (_b = event.data) === null || _b === void 0 ? void 0 : _b.embedId;
        if (embedId === this.getId()) {
          this.executeCallbacks(eventType, event.data);
        }
      });
    }
    getEmbedBasePath() {
      return `${this.thoughtSpotHost}/#/embed/${this.getId()}`;
    }
    renderIFrame(url, frameOptions) {
      if (!this.thoughtSpotHost) {
        this.throwInitError();
      }
      this.executeCallbacks(exports.EventType.Init, {
        data: {
          timestamp: Date.now()
        }
      });
      this.iFrame = document.createElement("iframe");
      this.iFrame.src = url;
      this.iFrame.width = `${frameOptions.width || DEFAULT_EMBED_WIDTH}`;
      this.iFrame.height = `${frameOptions.height || DEFAULT_EMBED_HEIGHT}`;
      this.iFrame.style.border = "0";
      this.iFrame.name = "ThoughtSpot Embedded Analytics";
      this.iFrame.addEventListener("load", () =>
        this.executeCallbacks(exports.EventType.Load, {
          data: {
            timestamp: Date.now()
          }
        })
      );
      this.el.appendChild(this.iFrame);
      this.subscribeToEvents();
    }
    getId() {
      return this.id;
    }
    getThoughtSpotHost() {
      return this.thoughtSpotHost;
    }
    on(messageType, callback) {
      const callbacks = this.eventHandlerMap.get(messageType) || [];
      callbacks.push(callback);
      this.eventHandlerMap.set(messageType, callbacks);
      return this;
    }
    trigger(messageType, data) {
      this.iFrame.contentWindow.postMessage(
        {
          type: messageType,
          data
        },
        this.thoughtSpotHost
      );
      return this;
    }
  }
  class SearchEmbed extends TsEmbed {
    constructor(domSelector, viewConfig) {
      super(domSelector);
      this.viewConfig = viewConfig;
    }
    getIFrameSrc(answerId) {
      const answerPath = answerId ? `saved-answer/${answerId}` : "answer";
      return `${this.getEmbedBasePath()}/${answerPath}`;
    }
    render(dataSources, query, answerId) {
      const src = this.getIFrameSrc(answerId);
      this.renderIFrame(src, this.viewConfig.frameParams);
      return this;
    }
  }

  exports.SearchEmbed = SearchEmbed;
  exports.init = init;

  Object.defineProperty(exports, "__esModule", { value: true });
});

